(define num car)
(define mul cdr)
(define summand cons)

(define (part-merge K N)
;  (display (format "~a\n~a\n" K N))
  (cond ((empty? K) N)
        ((empty? N) K)
        (else (let ((n (car N))
                    (k (car K)))
                (cond ((< (num n) (num k)) (cons n (part-merge K (cdr N))))
                      ((< (num k) (num n)) (cons k (part-merge (cdr K) N)))
                      (else (cons (summand (num k) (+ (mul k) (mul n)))
                                  (part-merge (cdr K) (cdr N)))))))))

(define (part-merge-all K N) (for*/list ((k K) (n N)) (part-merge k n)))

(define (partitions P n)
  (for/fold ((parts '())
             #:result (append parts (list (list (summand n 1)))))
            ((k (in-range 0 (+ 1 (quotient n 2)))))
            (append parts (part-merge-all (vector-ref P k)
                                          (vector-ref P (- n k))))))

(define (part n)
  (let ((P (make-vector (+ 1 n) '())))
    (for ((m (in-range 1 (+ 1 n))))
      (vector-set! P m (partitions P m)))
    (vector-ref P n)))
