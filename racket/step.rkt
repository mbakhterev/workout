(require racket/fixnum)

(define (sieve! v p)
  (let ((l (bytes-length v)))
    (do ((i (fx* 2 p) (fx+ i p)))
        ((fx>= i l))
        (bytes-set! v i 0))))

(define (make-initial-vector n) (let ((v (make-bytes (fx+ 1 n) 1)))
                                  (bytes-set! v 0 0)
                                  (bytes-set! v 1 0)
                                  (sieve! v 2)
                                  v))

(define (next-prime v start)
  (let ((l (bytes-length v)))
    (let loop ((i (fx+ 1 start)))
      (cond ((fx>= i l) 0)
            ((fx= 1 (bytes-ref v i)) i)
            (else (loop (fx+ 1 i)))))))

(define (step g m n)
  (let ((v (make-initial-vector n)))
    (let loop ((c-prime 2))
      (if (and (fx<= m c-prime (+ g c-prime) n)
               (fx= 1 (bytes-ref v (fx+ g c-prime))))
          (cons c-prime (fx+ g c-prime))
          (let ((n-prime (next-prime v c-prime)))
            (if (fx= 0 n-prime)
                '()
                (begin (sieve! v n-prime) (loop n-prime))))))))
