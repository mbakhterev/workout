Вс мая 12 17:32:11 +05 2019

При решении db-linear на Racket возникла проблема в реализации биномиальной
кучи. В одном месте вместо кучи передавалось дерево. Система типов это бы
обнаружила сразу. В Racket потребовалась относительно напряжённая отладка.
Возможно, причина в том, что Racket плохо отображает трассы вызовов.

P.S. Важное обстоятельство случившегося. Переписывал код из книги PFDS, а в этой
книге и в кодируемой функции был разный порядок аргументов. Поэтому случилась
ошибка.

Чт мая 16 20:06:46 +05 2019

Так, ладно... После решения partitions появилось несколько эмоций. Парочка,
наверное.

1. Было несколько вариантов решения, через, так скажем, существенно разнотипные
(в житейском смысле) однородные структуры данных: списки списков списков пар
чисел.  Мысль о том, что вот здесь бы хорошо для этого было бы применить типы,
для различия элементов была обнадёживающей. А невозможность это сделать из-за
правил эксперимента вызывала тревогу и дискомфорт.

Это психологические проблемы, а не технические. Однако, возможно, вызваны
техническими проблемами. Потому что в итоге, в бестиповом варианте кода пришлось
бы писать слишком однородные доступы к элементам структур данных, и это
запутывало бы нотацию и крайне осложняло бы прослеживание логики программы, её
отладку и редактирование. Тем более, что это всё нужно было писать на Racket, то
есть, куча скобочек.

2. Однако. Эти страхи заставили остановиться и задуматься над самим алгоритмом и
над самими структурами данных: как сделать проще, чтобы не взорвать себе мозг.

В итоге, было найдено более технически простое, более эффективное и более
очевидное решение, опирающееся на математические свойства чисел. Ну, что-то
вроде, раз n = k + m, где n > k > 0 и n > m > 0, то можно организовать простой
перенос свойств от слагаемых к сумме в простых терминах простой функции combine
и использовать динамическое программирование.

Вывод: невозможность воспользоваться типами и сложным синтаксисом привела к
более простой и эффективной структуре программы. Думается, что в типизированном
языке решение было бы получено примерно такое же, но потребовалось бы написать
больше кода, потому что было бы психологически проще лепить технически сложный
вариант

Пн мая 20 11:09:41 +05 2019

Ладно. Наблюдения по мотивам ещё двух решённых задач.

1. Haskell стимулирует программиста к работе с общими абстрактными концепциями.
Например, вместо регулярных выражений и конечных автоматов предлагается
использовать комбинаторный монадический парсер. При этом реализации некоторых
классов, необходимые для того, чтобы создать требуемую абстракцию, уже являются
весьма абстрактными. 

Например, для монадического парсера необходимо запрограммировать
applicative-поведение. А это поведение в контексте парсера весьма абстрактно.
Что означает f <*> m, то есть, применение функции f с эффектом к значению m с
эффектом. И если про значением m с эффектом ещё понятно, то что такое функция в
контексте эффекта синтаксического разбора некоторой строки? Не очевидно.

И вот типы позволяют эту неочевидность хоть как-то согласовать. Но поток данных
при этом, всё равно остаётся не очевидным, и дополнительно запутанным.

Более того, в Haskell типы позволяют автоматически вывести реализации всех
необходимых функций для Functor, Applicative, Alternative и Monad. И многие
этим пользуются. Но возникает вопрос: а как можно быть уверенными в поведении
такого кода? Это создаёт внутреннее напряжение.

2. Во всём этом есть и психологический эффект. Когда приходит понимание, как все
эти абстракции согласуются и работают, возникает больший объём удовольствия, чем
при программировании на языках, где не требуется программирования таких сложных
вычислительных схем.

3. Монадический парсер в Haskell написать, кажется, проще, чем средних размеров
автомат, разбирающий строку явно по условиям. Этот парсер, в итоге, собирается в
такой же автомат, что был бы написан вручную (по крайней мере, в очень похожий
код, в котором глубоко зарыты традиционные переключения по текущему символу).
Это проще сделать в Haskell, чем автомат на case-ах, в большей степени из-за
особенностей синтаксиса. Он менее приветливый к написанию больших структур, чем
синтаксис S-выражений. А монадический парсер собирается из небольших функций.

4. В следующей задаче, решённой на Racket, полезли обычные проблемы: выражение
оценивается к тому моменту, когда оно выполняется. Это, видимо, так и должно
быть в динамических языках. И это тоже своеобразное 

Сб мая 25 03:02:30 +05 2019

Задачка о нулях в хвосте факториала решена. Подобно задаче с посадкой на Марс, в
этой задаче очень хотелось для избежания путаницы между делителями и делимыми
дополнительно помечать их типом. Это было сделано при помощи пары типов Factor и
Product. Что же...

1. Путаницы, действительно, удалось избежать.

2. Однако, ценой того, что пришлось несколько усложнить код дополнительными
процедурами для распаковки типов и некоторых операций с ними. Я бы сказал, что
вместо путаницы в программе, я получил путаницу в голове.

3. Дополнительные сложности возникли из-за типа самой

    zeroes :: Integral a => a -> a -> a

пришлось возиться с преобразованиями типов. Если бы Factor и Product тоже были
бы просто параметризованы через Integral a, это бы пришлось оформлять, видимо
(не уверен, но, кажется, ограничения на типы в объявлениях типов не работают без
каких-нибудь магических расширений), через классы типов, и нагромождение
дополнительного кода было бы ещё тяжелее. Поэтому, пришлось добавлять
разнообразные преобразования, то есть упаковку/распаковку.

4. В итоге, эта сосредоточенность над типами нанесла ущерб сосредоточенности над
задачей. И первый вариант алгоритма оказался некорректным. К тому же, в нём
использовалось больше ветвлений, чем необходимо. Это и для производительности
хуже, и для чтения/записи программы в целом. Думается, если бы мысли не были
заняты типами, условия я бы упростил раньше. Насчёт верного решения с первого
раза не уверен, но точно уверен, что именно раздумья над типами не позволили
более детально проанализировать программу.

5. Всё же... Возможно, путаница в параметрах не так страшна. От того, что она не
возникла, я даже испытал некоторое сожаление, потому что не получил шанса
укрепить, так сказать, свою интуицию охотника за багами. 

Сб мая 25 22:08:42 +05 2019

На этот раз попалась прямо противоположная задачка. Условие было сформулировано
довольно мутно, и чтобы пройти тесты, пришлось несколько раз переписывать
основные процедуры решения. При этом, пришлось всякий раз менять структуру
данных. Если типы были бы зафиксированы, то изменения давались бы каждый раз
тяжелее.

Возможно, код можно было бы абстрагировать в виде классов, но кодировать того
пришлось бы больше и тяжелее. И, возможно, для формулировки правильных классов
не хватило бы итераций для вычленения этой самой общей логики.

А без типов получилось несколько раз поменять структуру легко и непринуждённо.
Это фактор.
