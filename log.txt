Вс мая 12 17:32:11 +05 2019

При решении db-linear на Racket возникла проблема в реализации биномиальной
кучи. В одном месте вместо кучи передавалось дерево. Система типов это бы
обнаружила сразу. В Racket потребовалась относительно напряжённая отладка.
Возможно, причина в том, что Racket плохо отображает трассы вызовов.

P.S. Важное обстоятельство случившегося. Переписывал код из книги PFDS, а в этой
книге и в кодируемой функции был разный порядок аргументов. Поэтому случилась
ошибка.

Чт мая 16 20:06:46 +05 2019

Так, ладно... После решения partitions появилось несколько эмоций. Парочка,
наверное.

1. Было несколько вариантов решения, через, так скажем, существенно разнотипные
(в житейском смысле) однородные структуры данных: списки списков списков пар
чисел.  Мысль о том, что вот здесь бы хорошо для этого было бы применить типы,
для различия элементов была обнадёживающей. А невозможность это сделать из-за
правил эксперимента вызывала тревогу и дискомфорт.

Это психологические проблемы, а не технические. Однако, возможно, вызваны
техническими проблемами. Потому что в итоге, в бестиповом варианте кода пришлось
бы писать слишком однородные доступы к элементам структур данных, и это
запутывало бы нотацию и крайне осложняло бы прослеживание логики программы, её
отладку и редактирование. Тем более, что это всё нужно было писать на Racket, то
есть, куча скобочек.

2. Однако. Эти страхи заставили остановиться и задуматься над самим алгоритмом и
над самими структурами данных: как сделать проще, чтобы не взорвать себе мозг.

В итоге, было найдено более технически простое, более эффективное и более
очевидное решение, опирающееся на математические свойства чисел. Ну, что-то
вроде, раз n = k + m, где n > k > 0 и n > m > 0, то можно организовать простой
перенос свойств от слагаемых к сумме в простых терминах простой функции combine
и использовать динамическое программирование.

Вывод: невозможность воспользоваться типами и сложным синтаксисом привела к
более простой и эффективной структуре программы. Думается, что в типизированном
языке решение было бы получено примерно такое же, но потребовалось бы написать
больше кода, потому что было бы психологически проще лепить технически сложный
вариант
