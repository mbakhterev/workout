Lander-2: Вс мар 12 15:58:28 +05 2017

Всё же слишком пространство состояний большее, а относительные изменения
маленькие. Хотя, может быть, я просто не умею решать такие задачи. Тут надо
посерьёзнее математическую часть изучать.

По лекциям Yandex и Gym вроде как, на ум приходят какой-нибудь случайный поиск.
И даже примерно понятно, как его можно попробовать сделать:

  1. С одной стороны просчитываем вероятности и цены исходя из конечной точки.

  2. С другой стороны, со стороны модуля пытаемся понять, как добраться до
  лучшей ситуации в каждый момент времени.

  3. Тут, конечно, будут свои проблемы и сложности. Но, по крайней мере,
  дискретизации по скорости не нужно будет. Ну, так кажется.

Но сейчас надо попробовать более механический способ. Надо разбить весь полёт на
несколько стадий:

  1. Разворот в нужную сторону.

  2. Приближение к посадочной площадке.

  3. Торможение.

  4. Коррекция дрифта.

  5. Посадка.

На каждом этапе можно использовать постоянное управление (а потом, в принципе,
наверное, можно мельчить эти стадии).

Если по мощностям и углам считать, то у нас довольно много вариантов:

 (expt (* 180 4) 5) = 193491763200000

Но довольно много вещей можно зарезать сразу же. А после каждого этапа выбирать,
решения в порядке экономичности.

Для каждого этапа надо задать условия начала и остановки. Но сначала нужно
изменить move, чтобы он учитывал инерцию двигателя и поворота. И выбросить
ошмётки.

Вс апр  9 09:56:19 +05 2017

Логика слишком неоднородная, поэтому и функции довольно корявые. Нужно менять
move, чтобы был более универсальным.

Нужен, видимо move-while и ещё такие подобные штуки.

move точно должен справляться с разными интервалами времени и разным контролем.
Тотальные функции лучше. Вроде как.

Аннотации типов не помогают, к сожалению. Можно убирать, чтобы не загромождать
код.

Сб апр 15 22:29:29 +05 2017

Что-то хрень какая-то. Не ясно, откуда вылезает этот контроль (20 4) на 3-й
стадии первого теста. Надо переписывать код трассировки и поиска.

Нужно делать цикл.

Вт июл 25 10:29:27 +05 2017

Так. Какая-то снова странная проблема с тем, чтобы сделать адекватное рисующееся
состояние.

1. Рисовать надо по кусочкам траекторий. Так? Так.
2. Поэтому состояние такое и должно быть.

3. Для отслеживания самого модуля. Тоже годятся кусочки траекторий. Но проблема
   в том, что надо добывать как-то последнее из состояний. Последнее из
   состояний - это approximate-last. Так? Так. В чём тогда проблема?

4. Проблема в переходе между циклом ожидания, циклом следования и циклом
   ожидания снова. Для сшивания нужна текущая позиция модуля. Значит, её и надо
   возвращать. Или её можно получать через очередной read?

5. Лучше это сделать внешним образом, так будет больше контроля и, возможно,
   точность выше. Если успеем просчитать guide до истечения timeout-а, то можно
   сэкономить на одном зависающем движении.

6. Ещё одна проблема. Как представлять guide. Потому что для управления нужен
   просто список движений, а для рисования нужен набор кусочков. В принципе,
   можно и одним куском, но для контроля лучше всё же иметь кусочное
   представление.

   На этот случай есть refine-guide.

7. Ещё вопрос о том, кто рисует данные. По идее, кто посчитал, тот и рисует? Ну,
   по идее, так, действительно должно быть удобнее.

8. Видимо, просчитанные группы наборы этапов надо накапливать в списки для
   отладки и рисования. Поэтому вместо traces нужно какое-то state и функции для
   манипуляции ими.

9. Отлично. Но мазахизм крепчает.
