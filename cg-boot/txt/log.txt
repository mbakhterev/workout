Lander-2: Вс мар 12 15:58:28 +05 2017

Всё же слишком пространство состояний большее, а относительные изменения
маленькие. Хотя, может быть, я просто не умею решать такие задачи. Тут надо
посерьёзнее математическую часть изучать.

По лекциям Yandex и Gym вроде как, на ум приходят какой-нибудь случайный поиск.
И даже примерно понятно, как его можно попробовать сделать:

  1. С одной стороны просчитываем вероятности и цены исходя из конечной точки.

  2. С другой стороны, со стороны модуля пытаемся понять, как добраться до
  лучшей ситуации в каждый момент времени.

  3. Тут, конечно, будут свои проблемы и сложности. Но, по крайней мере,
  дискретизации по скорости не нужно будет. Ну, так кажется.

Но сейчас надо попробовать более механический способ. Надо разбить весь полёт на
несколько стадий:

  1. Разворот в нужную сторону.

  2. Приближение к посадочной площадке.

  3. Торможение.

  4. Коррекция дрифта.

  5. Посадка.

На каждом этапе можно использовать постоянное управление (а потом, в принципе,
наверное, можно мельчить эти стадии).

Если по мощностям и углам считать, то у нас довольно много вариантов:

 (expt (* 180 4) 5) = 193491763200000

Но довольно много вещей можно зарезать сразу же. А после каждого этапа выбирать,
решения в порядке экономичности.

Для каждого этапа надо задать условия начала и остановки. Но сначала нужно
изменить move, чтобы он учитывал инерцию двигателя и поворота. И выбросить
ошмётки.

Вс апр  9 09:56:19 +05 2017

Логика слишком неоднородная, поэтому и функции довольно корявые. Нужно менять
move, чтобы был более универсальным.

Нужен, видимо move-while и ещё такие подобные штуки.

move точно должен справляться с разными интервалами времени и разным контролем.
Тотальные функции лучше. Вроде как.

Аннотации типов не помогают, к сожалению. Можно убирать, чтобы не загромождать
код.

Сб апр 15 22:29:29 +05 2017

Что-то хрень какая-то. Не ясно, откуда вылезает этот контроль (20 4) на 3-й
стадии первого теста. Надо переписывать код трассировки и поиска.

Нужно делать цикл.

Вт июл 25 10:29:27 +05 2017

Так. Какая-то снова странная проблема с тем, чтобы сделать адекватное рисующееся
состояние.

1. Рисовать надо по кусочкам траекторий. Так? Так.
2. Поэтому состояние такое и должно быть.

3. Для отслеживания самого модуля. Тоже годятся кусочки траекторий. Но проблема
   в том, что надо добывать как-то последнее из состояний. Последнее из
   состояний - это approximate-last. Так? Так. В чём тогда проблема?

4. Проблема в переходе между циклом ожидания, циклом следования и циклом
   ожидания снова. Для сшивания нужна текущая позиция модуля. Значит, её и надо
   возвращать. Или её можно получать через очередной read?

5. Лучше это сделать внешним образом, так будет больше контроля и, возможно,
   точность выше. Если успеем просчитать guide до истечения timeout-а, то можно
   сэкономить на одном зависающем движении.

6. Ещё одна проблема. Как представлять guide. Потому что для управления нужен
   просто список движений, а для рисования нужен набор кусочков. В принципе,
   можно и одним куском, но для контроля лучше всё же иметь кусочное
   представление.

   На этот случай есть refine-guide.

7. Ещё вопрос о том, кто рисует данные. По идее, кто посчитал, тот и рисует? Ну,
   по идее, так, действительно должно быть удобнее.

8. Видимо, просчитанные группы наборы этапов надо накапливать в списки для
   отладки и рисования. Поэтому вместо traces нужно какое-то state и функции для
   манипуляции ими.

9. Отлично. Но мазахизм крепчает.


Пт авг 25 15:19:01 +05 2017

Опять крепчает. Вопрос о необходимой для стадии информации. По идее, необходимо

  (and (добираться до target-линии)
       (не залететь под line)
       (не вылететь слишком высоко)
       (не вылететь за границу, видимо, в общем случае за границу отрезка, противоположную)).

Ладно. Что дальше? По идее, это всё должно решаться time-to-intersect с линиями.
Значит, нужны линии. Но это куча дополнительного счёта. Можно пересекать
траекторию с x = ax, и x = by, и y = upper-bound.

Надо бы direction

Вт сен  5 12:55:22 +05 2017

Жаба давит в align-циклах использовать тяжёлую арифметику с пересечениями.
Вообще, такие ситуации с обратными залётами или пересечениями через касания
вполне возможны. Тут возникает вопрос: мы хотим корректность или же скорость.
Корректность будет стоить нам того, что траектории просчитываться будут дольше,
и, как результат, отклонения будут больше. И, как результат, перерасчёт будет
нужен чаще.

С другой стороны, лучше иметь максимально корректную версию, а потом уже
вычёркивать проверки, понимая, что делаю.

Да будет так пока.

Вт сен  5 15:06:32 +05 2017

Нужно учесть, что модуль может быть на opposite-границе стадии. И решением на
пересечение может быть 0.

Ср сен  6 21:10:38 +05 2017

Хьюстон, у нас проблема. Если (:x lander) близко к какой-нибудь границе отрезка
bx (без ограничения общности), то решение уравнения о пересечении может дать
нулевое решение. Мы можем сказать, что можем игнорировать такое нулевое решение,
и нас интересуют только положительные корни.

Но в этом случае может быть такая ситуация. Пусть

  tx = 1
  bx = 0
  x  = 0
  vx = -1
  ax = -1

Такая штука вылетит за границы отрезка. Ненулевого корня тут не будет. И что? И
то, что такая штука пройдёт тесты. А по факту это вылет.

Самое простое откорректировать это контролем за положением модуля. Проверять
этот вылет и возвращать knock-out.
