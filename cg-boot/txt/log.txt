Lander-2: Вс мар 12 15:58:28 +05 2017

Всё же слишком пространство состояний большее, а относительные изменения
маленькие. Хотя, может быть, я просто не умею решать такие задачи. Тут надо
посерьёзнее математическую часть изучать.

По лекциям Yandex и Gym вроде как, на ум приходят какой-нибудь случайный поиск.
И даже примерно понятно, как его можно попробовать сделать:

  1. С одной стороны просчитываем вероятности и цены исходя из конечной точки.

  2. С другой стороны, со стороны модуля пытаемся понять, как добраться до
  лучшей ситуации в каждый момент времени.

  3. Тут, конечно, будут свои проблемы и сложности. Но, по крайней мере,
  дискретизации по скорости не нужно будет. Ну, так кажется.

Но сейчас надо попробовать более механический способ. Надо разбить весь полёт на
несколько стадий:

  1. Разворот в нужную сторону.

  2. Приближение к посадочной площадке.

  3. Торможение.

  4. Коррекция дрифта.

  5. Посадка.

На каждом этапе можно использовать постоянное управление (а потом, в принципе,
наверное, можно мельчить эти стадии).

Если по мощностям и углам считать, то у нас довольно много вариантов:

 (expt (* 180 4) 5) = 193491763200000

Но довольно много вещей можно зарезать сразу же. А после каждого этапа выбирать,
решения в порядке экономичности.

Для каждого этапа надо задать условия начала и остановки. Но сначала нужно
изменить move, чтобы он учитывал инерцию двигателя и поворота. И выбросить
ошмётки.

Вс апр  9 09:56:19 +05 2017

Логика слишком неоднородная, поэтому и функции довольно корявые. Нужно менять
move, чтобы был более универсальным.

Нужен, видимо move-while и ещё такие подобные штуки.

move точно должен справляться с разными интервалами времени и разным контролем.
Тотальные функции лучше. Вроде как.

Аннотации типов не помогают, к сожалению. Можно убирать, чтобы не загромождать
код.

Сб апр 15 22:29:29 +05 2017

Что-то хрень какая-то. Не ясно, откуда вылезает этот контроль (20 4) на 3-й
стадии первого теста. Надо переписывать код трассировки и поиска.

Нужно делать цикл.

Вт июл 25 10:29:27 +05 2017

Так. Какая-то снова странная проблема с тем, чтобы сделать адекватное рисующееся
состояние.

1. Рисовать надо по кусочкам траекторий. Так? Так.
2. Поэтому состояние такое и должно быть.

3. Для отслеживания самого модуля. Тоже годятся кусочки траекторий. Но проблема
   в том, что надо добывать как-то последнее из состояний. Последнее из
   состояний - это approximate-last. Так? Так. В чём тогда проблема?

4. Проблема в переходе между циклом ожидания, циклом следования и циклом
   ожидания снова. Для сшивания нужна текущая позиция модуля. Значит, её и надо
   возвращать. Или её можно получать через очередной read?

5. Лучше это сделать внешним образом, так будет больше контроля и, возможно,
   точность выше. Если успеем просчитать guide до истечения timeout-а, то можно
   сэкономить на одном зависающем движении.

6. Ещё одна проблема. Как представлять guide. Потому что для управления нужен
   просто список движений, а для рисования нужен набор кусочков. В принципе,
   можно и одним куском, но для контроля лучше всё же иметь кусочное
   представление.

   На этот случай есть refine-guide.

7. Ещё вопрос о том, кто рисует данные. По идее, кто посчитал, тот и рисует? Ну,
   по идее, так, действительно должно быть удобнее.

8. Видимо, просчитанные группы наборы этапов надо накапливать в списки для
   отладки и рисования. Поэтому вместо traces нужно какое-то state и функции для
   манипуляции ими.

9. Отлично. Но мазахизм крепчает.


Пт авг 25 15:19:01 +05 2017

Опять крепчает. Вопрос о необходимой для стадии информации. По идее, необходимо

  (and (добираться до target-линии)
       (не залететь под line)
       (не вылететь слишком высоко)
       (не вылететь за границу, видимо, в общем случае за границу отрезка, противоположную)).

Ладно. Что дальше? По идее, это всё должно решаться time-to-intersect с линиями.
Значит, нужны линии. Но это куча дополнительного счёта. Можно пересекать
траекторию с x = ax, и x = by, и y = upper-bound.

Надо бы direction

Вт сен  5 12:55:22 +05 2017

Жаба давит в align-циклах использовать тяжёлую арифметику с пересечениями.
Вообще, такие ситуации с обратными залётами или пересечениями через касания
вполне возможны. Тут возникает вопрос: мы хотим корректность или же скорость.
Корректность будет стоить нам того, что траектории просчитываться будут дольше,
и, как результат, отклонения будут больше. И, как результат, перерасчёт будет
нужен чаще.

С другой стороны, лучше иметь максимально корректную версию, а потом уже
вычёркивать проверки, понимая, что делаю.

Да будет так пока.

Вт сен  5 15:06:32 +05 2017

Нужно учесть, что модуль может быть на opposite-границе стадии. И решением на
пересечение может быть 0.

Ср сен  6 21:10:38 +05 2017

Хьюстон, у нас проблема. Если (:x lander) близко к какой-нибудь границе отрезка
bx (без ограничения общности), то решение уравнения о пересечении может дать
нулевое решение. Мы можем сказать, что можем игнорировать такое нулевое решение,
и нас интересуют только положительные корни.

Но в этом случае может быть такая ситуация. Пусть

  tx = 1
  bx = 0
  x  = 0
  vx = -1
  ax = -1

Такая штука вылетит за границы отрезка. Ненулевого корня тут не будет. И что? И
то, что такая штука пройдёт тесты. А по факту это вылет.

Самое простое откорректировать это контролем за положением модуля. Проверять
этот вылет за границы и возвращать knock-out. Тяжеловатая логика получается.
Почему тяжеловатая, потому что мы хотим возвращать со статусом ko последний
живой модуль.

Ну. Как. Тогда придётся пересчитать x, y и сделать проверки. Это надёжнее,
вероятно, чем тонкая настройка равенств или неравенств. Рассчёты можно через if
разделить. Если находимся на линии, то считаем по конечному положению. Если не
на линии, то вторым.

Ладно. Значит, получается так: проверяем на dt. Если условие на пересечение
выполнено, то всё плохо. Если не выполнено, тогда если dt близко. Да хрень!

Ср сен 13 12:20:50 +05 2017

Вот в этом месте

(defn- brake-guide [^geometry.Stage stage next-stages ^Lander lander]
  (if (brake-initial-ok? lander stage)
    (loop [cloud (keep (partial brake-integrate stage lander) (brake-control-cloud lander))]
      (when-first [m cloud]
        (let [k (:lander (first m))
              l (:lander (second m))]
          (if-let [m-next (search-guide next-stages (assoc l :control (:control k)))]
            (cons m m-next)
            (recur (next cloud))))))))

KL-чехарду надо бы убрать из этого места в brake-integrate. Хотя, не факт, что
мути будет меньше. Пока оставляю текущий вариант.

Вт сен 19 14:44:31 +05 2017

Напоминание. Вся эта работа посвящена одной цели: исследованию лексических,
синтаксических и семантических возможностей разных языков программирования для
того, чтобы выбрать некий оптимум для LiME/DART/RiDE или как там ещё он будет
называться.

Сейчас будет большой rewrite кода Lander-2, в ходе которого будут проверены:

  1. Бесчувственность к регистру: везде будет нижний регистр букв. Как это
     повлияет на выразительность?
  
  2. Плоские пространства имён, когда из модуля забирается весь экспорт без
     префиксов.

Хорошо. Поехали

Вт сен 19 15:23:37 +05 2017

Стоп. Опомнись. Мы же собираемся RiDE использовать и для математики, чтобы можно
было формулы верстать. А как там без заглавных букв? И означать они должны
разное.

Делать же разницу между визуальным и внутренним представлением, когда оба
значимы -- это уже перебор.

Далее, почему плоские пространства имён? Это могло бы быть технически проще,
если бы не было идеи о структурированных атомах. Но с этим может быть столько
боли. Структурируемые атомы могут быть только в "тексте".

Ок. Пока такая комбинация: сейчас плоские пространства имён и чувствительность к
регистру (ради науки). Ну, потому что, забавнее писать так:

(import (begin (import qt) (export (qt.Button Button) (qt.Window Window))))
(import (begin (import gtk) (export (gtk.Button Button) (gtk.Window Window))))

а не так: (import qt as qt) (import gtk as gtk).

Хотя. Чёрт его знает. Но переименование может быть и через макрос можно сделать.
При этом атомы у нас тут осмысленно структурные. И всё плоское. Но тут возникает
вопрос:

  А как же векторные пространства, когда мы хотим многообразный «+»? Доступ к
  элементам стркутур, кстати, как частный случай этого.

Ладно. Может быть две формы. (import module) (import prefix module).

Это на будущее. Сейчас - регистр плюс плоский импорт.

Вт сен 19 18:17:07 +05 2017

Будущее наступило, потому что началось такое:

(defn- in-range? [^Lander {x :x} ^geometry.Section s] (g/in-range? x s))
(defn- over-line? [^Lander {x :x y :y} ^geometry.Section s] (g/over-line? s x y))

Ну. Отлично. И каково решение? Через перегрузку? Навешивать префиксы на всё
нельзя, потому что есть core, как минимум. Ну и всякие радости типа «+». Надо
перечитывать и думать.
