Lander-2: Вс мар 12 15:58:28 +05 2017

Всё же слишком пространство состояний большее, а относительные изменения
маленькие. Хотя, может быть, я просто не умею решать такие задачи. Тут надо
посерьёзнее математическую часть изучать.

По лекциям Yandex и Gym вроде как, на ум приходят какой-нибудь случайный поиск.
И даже примерно понятно, как его можно попробовать сделать:

  1. С одной стороны просчитываем вероятности и цены исходя из конечной точки.

  2. С другой стороны, со стороны модуля пытаемся понять, как добраться до
  лучшей ситуации в каждый момент времени.

  3. Тут, конечно, будут свои проблемы и сложности. Но, по крайней мере,
  дискретизации по скорости не нужно будет. Ну, так кажется.

Но сейчас надо попробовать более механический способ. Надо разбить весь полёт на
несколько стадий:

  1. Разворот в нужную сторону.

  2. Приближение к посадочной площадке.

  3. Торможение.

  4. Коррекция дрифта.

  5. Посадка.

На каждом этапе можно использовать постоянное управление (а потом, в принципе,
наверное, можно мельчить эти стадии).

Если по мощностям и углам считать, то у нас довольно много вариантов:

 (expt (* 180 4) 5) = 193491763200000

Но довольно много вещей можно зарезать сразу же. А после каждого этапа выбирать,
решения в порядке экономичности.

Для каждого этапа надо задать условия начала и остановки. Но сначала нужно
изменить move, чтобы он учитывал инерцию двигателя и поворота. И выбросить
ошмётки.

Вс апр  9 09:56:19 +05 2017

Логика слишком неоднородная, поэтому и функции довольно корявые. Нужно менять
move, чтобы был более универсальным.

Нужен, видимо move-while и ещё такие подобные штуки.

move точно должен справляться с разными интервалами времени и разным контролем.
Тотальные функции лучше. Вроде как.

Аннотации типов не помогают, к сожалению. Можно убирать, чтобы не загромождать
код.
