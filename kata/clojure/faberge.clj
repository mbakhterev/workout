(ns faberge)

; Динамическое вычисление по формуле h(m,n) = h(m-1,n-1) + h(m-1,n) + 1 не
; достаточно производительны. И не ясно, как их можно ускорить за счёт
; изменения порядка операций. Логарифмический матричный метод не подойдёт,
; потому что в нём больше операций, чем в текущей реализации.
;
; Что ещё можно попробовать. Если порисовать схему счёта в динамическом
; программировании, то возникает интуиция, что всё зависит от количества путей
; из одного угла ромбика в другой. Каждый такой путь описывается местами
; «поворотов», то есть, местами разбития яйца. Хм...
;
; Дальше можно рассуждать так. Вот у нас есть m попыток и n яиц. В ходе
; эксперимента (не важно, как мы его проводим), у нас может побиться не более
; чем n яиц. Мы можем записать этот эксперимент последовательностью ноликов и
; единичек (единичка обозначает, что яйцо побилось). Каждое побитое и не побитое
; яйцо ведёт нас к принятию решения о том, как вести эксперимент дальше, и какой
; этаж является роковым для яиц. К решению о том, что роковым является
; конкретный этаж, ведёт некая конкретная цепочка попыток с конкретными
; побитыми/небитыми яйцами при каждой попытке. И только эта последовательность
; определяет этот конкретный этаж. В итоге, количество этажей, которые мы можем
; разрешить при помощи m попыток и n яиц -- это количество последовательностей
; длины m из 0 и 1, в которых не более n единичек. А это количество считается
; легко по формуле: h(m,n) = Σ λk.C(n,k) ∘ [1,m]

(defn height [n m]
  (binding [*out* *err*] (println n m))
  (if (>= n m)
    (bigint (.subtract (.shiftLeft BigInteger/ONE m) BigInteger/ONE))
    (loop [k 0 sum 0N cnk 1N]
      (if (= k n)
        sum
        (let [next-cnk (/ (* cnk (- m k)) (+ k 1))]
          (recur (+ 1 k) (+ sum next-cnk) next-cnk))))))
